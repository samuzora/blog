---
import Layout from "@layouts/Layout.astro";
import Card from "@components/Card.vue";
import Toc from "@components/Toc.vue";
import PostHeader from "@components/PostHeader.vue";
import { getCollection } from "astro:content";

export async function getStaticPaths() {
  const posts = await getCollection("blog");
  return posts.map(post => ({
    params: { 
      id: post.slug
    }
  }))
}

const posts = (await getCollection("blog")).sort((a, b) => a.data.date - b.data.date);

const postIndex = posts.findIndex(post => post.slug === Astro.params.id)

const post = posts[postIndex]
const prevPost = postIndex > 0 ? posts[postIndex - 1] : null;
const nextPost = postIndex < posts.length ? posts[postIndex + 1] : null;

const { Content, headings, remarkPluginFrontmatter } = await post.render();

// github.com/rezahedi/rezahedi.dev/blob/main/src/components/TOC.astro
// function buildHierarchy(headings: any)
// {
//   const toc: any[] = [];
//   const parentHeadings = new Map();
//
//   if (!headings)
//     return toc;
//
//   headings.forEach((h: any) => {
//     const heading = { ...h, subheadings: [] };
//     parentHeadings.set(heading.depth, heading);
//     // Change 2 to 1 if your markdown includes your <h1>
//     if (heading.depth === 1) {
//       toc.push(heading);
//     } else {
//       parentHeadings.get(heading.depth - 1).subheadings.push(heading);
//     }
//   });
//   return toc;
// }
//
// const nestedHeadings = buildHierarchy(headings);
---

<Layout title={post.data.title}>
  <div class="relative flex justify-center pt-[125px] px-6 md:px-32 xl:px-16 mx-auto">
    {
    // ToC for lg and above - appears on the side of content
    headings.length > 0 && 
    <div class="sticky lg:w-[125px] xl:w-[200px] self-start hidden lg:block mr-10 top-[125px] h-[calc(100vh-200px)] overflow-y-auto" ss-container>
      <div class="text-xl font-bold text-[--second-text-color] py-2">
        Contents
      </div>
      <Toc client:load headings={headings} />
    </div>
    }
    <div data-main-content class="flex flex-col gap-10 min-w-[300px] md:w-[748px] lg:max-w-[904px] xl:max-w-[1300px]">
      <div class="flex flex-col gap-2 relative">
        <Card class="!bg-[--primary-bg] items-center rounded-none md:rounded-lg -mx-6 md:mx-0 p-10">
          <div class="pb-10">
            <PostHeader client:load post={post} remarkPluginFrontmatter={remarkPluginFrontmatter} />
          </div>
          {
            // ToC for xs-md - appears between PostHeader and body
            headings.length > 0 &&
            <details open class="lg:hidden group p-5 mb-5 border border-[--secondary-bg] rounded-lg">
              <summary class="flex justify-between">
                <div class="text-xl font-bold text-[--second-text-color] py-2">
                  Contents
                </div>
              <i class="transition-all my-auto text-sm text-white fa-regular fa-chevron-down group-open:rotate-180"></i>
              </summary>
              <div ss-container class="h-[400px]">
                <Toc client:load headings={headings} />
              </div>
            </details>
          }
          <div class="markdown-body">
            <Content />
          </div>

          <div class="flex justify-between mt-6 pt-6 border-t border-[--secondary-bg]">
            {prevPost ? (
            <a class="p-3 border border-[--secondary-bg] rounded-lg" href={"/posts/" + prevPost.slug}>
                <i class="fa-regular fa-angle-left"></i>
                {prevPost.data.title}
              </a>
            ) : <div></div>
            }
            {nextPost ? (
            <a class="p-3 border border-[--secondary-bg] rounded-lg" href={"/posts/" + nextPost.slug}>
              {nextPost.data.title}
              <i class="fa-regular fa-angle-right"></i>
            </a>
            ) : <div></div>
            }
          </div>

          <script is:inline src="https://giscus.app/client.js"
            data-repo="samuzora/blog"
            data-repo-id="R_kgDOIp6e0Q"
            data-category="Announcements"
            data-category-id="DIC_kwDOIp6e0c4CfplK"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="bottom"
            data-theme="noborder_dark"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async
          ></script>
        </Card>
      </div>
    </div>
  </div>
</Layout>

<script>
// from SimpleScrollbar
;(function(root, factory) {
  if (typeof exports === 'object') {
    module.exports = factory(window, document)
  } else {
    root.SimpleScrollbar = factory(window, document)
  }
})(this || window, function(w, d) {
  var raf = w.requestAnimationFrame || w.setImmediate || function(c) { return setTimeout(c, 0); };

  function initEl(el) {
    Object.defineProperty(el, 'data-simple-scrollbar', { value: new SimpleScrollbar(el), configurable: true });
  }

  function unbindEl(el) {
    if (!Object.prototype.hasOwnProperty.call(el, 'data-simple-scrollbar')) return;
    el['data-simple-scrollbar'].unBind();
    //Remove the elements property
    delete el['data-simple-scrollbar'];
  }

  // Mouse drag handler
  function dragDealer(el, context) {
    var lastPageY;

    el.addEventListener('mousedown', function(e) {
      lastPageY = e.pageY;
      el.classList.add('ss-grabbed');
      d.body.classList.add('ss-grabbed');

      d.addEventListener('mousemove', drag);
      d.addEventListener('mouseup', stop);

      return false;
    });

    function drag(e) {
      var delta = e.pageY - lastPageY;
      lastPageY = e.pageY;

      raf(function() {
        context.el.scrollTop += delta / context.scrollRatio;
      });
    }

    function stop() {
      el.classList.remove('ss-grabbed');
      d.body.classList.remove('ss-grabbed');
      d.removeEventListener('mousemove', drag);
      d.removeEventListener('mouseup', stop);
    }
  }

  // Constructor
  function ss(el) {
    this.target = el;
    this.content = el.firstElementChild;

    this.direction = w.getComputedStyle(this.target).direction;

    this.bar = '<div class="ss-scroll">';
    //Create a reference to the function binding to remove the event listeners
    this.mB = this.moveBar.bind(this);

    this.wrapper = d.createElement('div');
    this.wrapper.setAttribute('class', 'ss-wrapper');

    this.el = d.createElement('div');
    this.el.setAttribute('class', 'ss-content');

    if (this.direction === 'rtl') {
      this.el.classList.add('rtl');
    }

    this.wrapper.appendChild(this.el);

    while (this.target.firstChild) {
      this.el.appendChild(this.target.firstChild);
    }
    this.target.appendChild(this.wrapper);

    this.target.insertAdjacentHTML('beforeend', this.bar);
    this.bar = this.target.lastChild;

    dragDealer(this.bar, this);
    this.moveBar();

    w.addEventListener('resize', this.mB);
    this.el.addEventListener('scroll', this.mB);
    this.el.addEventListener('mouseenter', this.mB);

    this.target.classList.add('ss-container');

    var css = w.getComputedStyle(el);
  	if (css['height'] === '0px' && css['max-height'] !== '0px') {
    	el.style.height = css['max-height'];
    }

    this.unBind = function() {
      //Remove event listeners
      w.removeEventListener('resize', this.mB);
      this.el.removeEventListener('scroll', this.mB);
      this.el.removeEventListener('mouseenter', this.mB);
      
      this.target.classList.remove('ss-container');

      //Unwrap the initial content and remove remaining wrappers
      this.target.insertBefore(this.content, this.wrapper);
      this.target.removeChild(this.wrapper);

      //Remove the bar including its drag-dealer event listener
      this.target.removeChild(this.bar);
      this.bar = null; //make way for the garbage collector
    }
  }

  ss.prototype = {
    moveBar: function(e) {
      var totalHeight = this.el.scrollHeight,
          ownHeight = this.el.clientHeight,
          _this = this;

      this.scrollRatio = ownHeight / totalHeight;

      var isRtl = _this.direction === 'rtl';
      var right = isRtl ?
        (_this.target.clientWidth - _this.bar.clientWidth + 18) :
        (_this.target.clientWidth - _this.bar.clientWidth) * -1;

      raf(function() {
        // Hide scrollbar if no scrolling is possible
        if(_this.scrollRatio >= 1) {
          _this.bar.classList.add('ss-hidden')
        } else {
          _this.bar.classList.remove('ss-hidden')
          _this.bar.style.cssText = 'height:' + Math.max(_this.scrollRatio * 100, 10) + '%; top:' + (_this.el.scrollTop / totalHeight ) * 100 + '%;right:' + right + 'px;';
        }
      });
    }
  }

  function initAll() {
    var nodes = d.querySelectorAll('*[ss-container]');

    for (var i = 0; i < nodes.length; i++) {
      initEl(nodes[i]);
    }
  }

  function unbindAll() {
    var nodes = d.querySelectorAll('.ss-container');

    for (var i = 0; i < nodes.length; i++) {
      unbindEl(nodes[i]);
    }
  }

  d.addEventListener('astro:page-load', initAll);
  ss.initEl = initEl;
  ss.initAll = initAll;
  ss.unbindEl = unbindEl;
  ss.unbindAll = unbindAll;

  var SimpleScrollbar = ss;
  return SimpleScrollbar;
});
</script>
